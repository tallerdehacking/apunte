<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-regular.woff2 type=font/woff2 crossorigin><link rel=preload as=font href=/fonts/vendor/jost/jost-v4-latin-700.woff2 type=font/woff2 crossorigin><link rel=stylesheet href=/main.e694d66a3c6fa2afcf7e22fe274cbf7b68826715be967e6a094a0037ad19d8af7fd4aea40cbda5561cbd6de1467925a993b85f84e42079c0ff1bf116de1b226c.css integrity="sha512-5pTWajxvoq/PfiL+J0y/e2iCZxW+ln5qCUoAN60Z2K9/1K6kDL2lVhy9beFGeSWpk7hfhOQgecD/G/EW3hsibA==" crossorigin=anonymous><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><title>Criptografía Simétrica - Taller de Hacking Competitivo</title><meta name=description content="DCC universidad de Chile"><link rel=canonical href=/docs/cripto-moderna/cripto-simetrica/><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="/logo_redondo.png"><meta name=twitter:title content="Criptografía Simétrica"><meta name=twitter:description content="En esta sección hablaremos de tres tipos de cifrado: One-time pad, cifradores de bloque y cifradores de flujo.
One-Time Pad Corresponde a una técnica de cifrado que no puede ser rota si la llave no se reusa, en la cual un mensaje se cifra ejecutando la operación xor entre un valor aleatorio al menos del tamaño del mensaje y el mismo mensaje. Lamentablemente, este tipo de cifrado no es muy práctico, debido a la dificultad de conseguir una fuente de valores realmente aleatorios que pueda al mismo tiempo estar sincronizada entre las partes que desean comunicarse."><meta name=twitter:site content="@dccuchile"><meta name=twitter:creator content="@dccuchile"><meta property="og:title" content="Criptografía Simétrica"><meta property="og:description" content="En esta sección hablaremos de tres tipos de cifrado: One-time pad, cifradores de bloque y cifradores de flujo.
One-Time Pad Corresponde a una técnica de cifrado que no puede ser rota si la llave no se reusa, en la cual un mensaje se cifra ejecutando la operación xor entre un valor aleatorio al menos del tamaño del mensaje y el mismo mensaje. Lamentablemente, este tipo de cifrado no es muy práctico, debido a la dificultad de conseguir una fuente de valores realmente aleatorios que pueda al mismo tiempo estar sincronizada entre las partes que desean comunicarse."><meta property="og:type" content="article"><meta property="og:url" content="/docs/cripto-moderna/cripto-simetrica/"><meta property="og:image" content="/logo_redondo.png"><meta property="article:published_time" content="2020-10-06T08:48:45+00:00"><meta property="article:modified_time" content="2025-04-01T21:28:03-03:00"><meta property="og:site_name" content="Taller de Hacking Competitivo"><meta property="article:publisher" content="https://www.facebook.com/DCCUChile"><meta property="article:author" content="https://www.facebook.com/DCCUChile"><meta property="og:locale" content="es_CL"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"\/"},{"@type":"ListItem","position":2,"name":"Docscripto Modernacripto Simetrica","item":"\/docscripto-modernacripto-simetrica\/"}]}</script><meta name=theme-color content="#fff"><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body class="docs single"><div class="header-bar fixed-top"></div><header class="navbar fixed-top navbar-expand-md navbar-light"><div class=container><input class="menu-btn order-0" type=checkbox id=menu-btn>
<label class="menu-icon d-md-none" for=menu-btn><span class=navicon></span></label><a class="navbar-brand order-1 order-md-0 mr-auto" href=/><img class=logo-light src=/images/banner.svg></img>
<img class=logo-dark src=/images/banner_dark.svg></img></a>
<button id=mode class="btn btn-link order-2 order-md-4" type=button aria-label="Toggle mode">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button><ul class="navbar-nav social-nav order-3 order-md-5"><li class=nav-item><a class=nav-link href=https://github.com/cc5325/apunte><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><span class="ml-2 sr-only">GitHub</span></a></li></ul><div class="collapse navbar-collapse order-4 order-md-1"><ul class="navbar-nav main-nav mr-auto order-5 order-md-2"><li class=nav-item><a class=nav-link href=/blog/>Videos</a></li><li class=nav-item><a class=nav-link href=/docs/prologo/intro>Apunte</a></li><li class=nav-item><a class=nav-link href=/writeups/>Writeups</a></li><li class=nav-item><a class=nav-link href=/tareas/>Evaluaciones</a></li><li class=nav-item><a class=nav-link href=/acerca>Acerca</a></li></ul><div class="break order-6 d-md-none"></div><form class="navbar-form flex-grow-1 order-7 order-md-3"><input id=userinput class="form-control is-search" type=search placeholder="Buscar Documentación..." aria-label="Buscar Documentación..." autocomplete=off><div id=suggestions class="shadow bg-white rounded"></div></form></div></div></header><div class="wrap container" role=document><div class=content><div class="row flex-xl-nowrap"><div class="col-lg-5 col-xl-4 docs-sidebar"><nav class=docs-links aria-label="Main navigation"><h3>Prólogo</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/prologo/intro/>Prólogo</a></li></ul><h3>Esteganografía</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/stego/intro/>Intro a la Esteganografía</a></li><li><a class=docs-link href=/docs/stego/conceptos-basicos/>Conceptos Básicos</a></li><li><a class=docs-link href=/docs/stego/cripto-clasica/>Criptografía Clásica</a></li><li><a class=docs-link href=/docs/stego/stego/>Stego en texto, imágenes y audio</a></li><li><a class=docs-link href=/docs/stego/ejercicios/>Ejercicios de Stego</a></li></ul><h3>Criptografía Moderna</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/cripto-moderna/intro/>Intro a Criptografía Moderna</a></li><li><a class=docs-link href=/docs/cripto-moderna/hashing/>Hashing</a></li><li><a class="docs-link active" href=/docs/cripto-moderna/cripto-simetrica/>Criptografía Simétrica</a></li><li><a class=docs-link href=/docs/cripto-moderna/cripto-asimetrica/>Criptografía Asimétrica</a></li><li><a class=docs-link href=/docs/cripto-moderna/ejercicios/>Ejercicios Cripto Moderna</a></li></ul><h3>Aplicaciones Web</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/apps-web/intro/>Intro a Aplicaciones Web</a></li><li><a class=docs-link href=/docs/apps-web/tecnicas-basicas/>Técnicas Básicas de Análisis Web</a></li><li><a class=docs-link href=/docs/apps-web/xss/>Cross-Site Scripting</a></li><li><a class=docs-link href=/docs/apps-web/inyecciones/>Inyecciones</a></li><li><a class=docs-link href=/docs/apps-web/rce/>Remote Code Execution</a></li><li><a class=docs-link href=/docs/apps-web/reverse-shell/>Reverse Shell</a></li><li><a class=docs-link href=/docs/apps-web/access-control/>Broken Access Control</a></li><li><a class=docs-link href=/docs/apps-web/cve/>Common Vulnerabilities and Exposures</a></li><li><a class=docs-link href=/docs/apps-web/ejercicios/>Ejercicios Apps Web</a></li></ul><h3>Análisis Forense</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/forense/intro/>Introducción al Análisis Forense</a></li><li><a class=docs-link href=/docs/forense/cmd-logs/>Comandos, Logs y Configuraciones</a></li><li><a class=docs-link href=/docs/forense/versionado-recuperacion/>Versionado y Recuperación de Archivos</a></li><li><a class=docs-link href=/docs/forense/wireshark/>Wireshark</a></li><li><a class=docs-link href=/docs/forense/ejercicios/>Ejercicios de Forense</a></li></ul><h3>Ingeniería Reversa</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/reversa/intro/>Intro a la Ingeniería Reversa</a></li><li><a class=docs-link href=/docs/reversa/decompiling/>Decompilación</a></li><li><a class=docs-link href=/docs/reversa/deobfuscation/>Deobfuscación</a></li><li><a class=docs-link href=/docs/reversa/ejercicios/>Ejercicios Reversing</a></li></ul><h3>Pwning</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/pwning/intro/>Intro al Pwning</a></li><li><a class=docs-link href=/docs/pwning/permisos-linux/>Permisos de Usuario en Linux</a></li><li><a class=docs-link href=/docs/pwning/escalamiento-privilegios/>Escalamiento de Privilegios</a></li><li><a class=docs-link href=/docs/pwning/buffer-overflow/>Buffer Overflow</a></li><li><a class=docs-link href=/docs/pwning/ejercicios/>Ejercicios de Pwning</a></li></ul><h3>OSINT</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/osint/intro/>Intro a OSINT</a></li><li><a class=docs-link href=/docs/osint/google/>Google Hacking</a></li><li><a class=docs-link href=/docs/osint/github/>Búsqueda en Github</a></li><li><a class=docs-link href=/docs/osint/theharvester/>The Harvester</a></li><li><a class=docs-link href=/docs/osint/haveibeenpwned/>Have I Been Pwned</a></li><li><a class=docs-link href=/docs/osint/shodan/>Shodan</a></li><li><a class=docs-link href=/docs/osint/ejercicios/>Ejercicios OSINT</a></li></ul><h3>Hardware</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/hardware/intro/>Intro a Hardware</a></li><li><a class=docs-link href=/docs/hardware/firmware/>Reversing de Firmware</a></li><li><a class=docs-link href=/docs/hardware/communication/>Protocolos de Comunicación</a></li><li><a class=docs-link href=/docs/hardware/ejercicios/>Ejercicios de Hardware</a></li></ul><h3>Anexos</h3><ul class=list-unstyled><li><a class=docs-link href=/docs/anexos/herramientas/>Herramientas</a></li><li><a class=docs-link href=/docs/anexos/vpn/>Configuración de VPN</a></li><li><a class=docs-link href=/docs/anexos/kali/>Kali Linux</a></li><li><a class=docs-link href=/docs/anexos/proxy/>Proxy</a></li><li><a class=docs-link href=/docs/anexos/comandos/>Comandos de Terminal de Linux</a></li><li><a class=docs-link href=/docs/anexos/referencias/>Referencias</a></li></ul></nav></div><nav class="docs-toc d-none d-xl-block col-xl-3" aria-label="Secondary navigation"><div class=page-links><h3>Contenidos</h3><nav id=TableOfContents><ul><li><a href=#one-time-pad>One-Time Pad</a></li><li><a href=#cifradores-de-bloque>Cifradores de bloque</a><ul><li><a href=#tipos-de-cifradores-de-bloque>Tipos de cifradores de bloque</a></li><li><a href=#modos-de-cifrado>Modos de Cifrado</a></li></ul></li><li><a href=#cifradores-de-flujo>Cifradores de Flujo</a><ul><li><a href=#el-_nonce_-en-los-cifradores-de-flujo>El <em>nonce</em> en los cifradores de flujo</a></li><li><a href=#rc4>RC4</a></li><li><a href=#chacha>ChaCha</a></li></ul></li><li><a href=#más-allá-del-cifrado>Más allá del cifrado</a><ul><li><a href=#mac>MAC</a></li><li><a href=#cifrar-y-autentificar-a-la-vez>Cifrar y autentificar a la vez</a></li><li><a href=#aes-gcm-bloque>AES-GCM (Bloque)</a></li><li><a href=#chacha20-poly1305-flujo>ChaCha20-Poly1305 (Flujo)</a></li></ul></li></ul></nav></div></nav><main class="docs-content col-lg-11 col-xl-9 mx-xl-auto"><h1>Criptografía Simétrica</h1><p class=lead></p><p>En esta sección hablaremos de tres tipos de cifrado: <strong>One-time pad</strong>, <strong>cifradores de bloque</strong> y <strong>cifradores de flujo</strong>.</p><h2 id=one-time-pad>One-Time Pad<a href=#one-time-pad class=anchor aria-hidden=true>#</a></h2><p>Corresponde a una técnica de cifrado que no puede ser rota si la llave no se reusa, en la cual un mensaje se cifra ejecutando la operación <code>xor</code> entre un valor aleatorio al menos del tamaño del mensaje y el mismo mensaje. Lamentablemente, este tipo de cifrado no es muy práctico, debido a la dificultad de conseguir una fuente de valores realmente aleatorios que pueda al mismo tiempo estar sincronizada entre las partes que desean comunicarse.</p><h2 id=cifradores-de-bloque>Cifradores de bloque<a href=#cifradores-de-bloque class=anchor aria-hidden=true>#</a></h2><p>Los cifadores de bloque permiten cifrar mensajes de un tamaño fijo (<em>conocido como $BlockSize$</em>) utilizando una llave de con otro tamaño fijo (<em>conocido como $KeySize$</em>). Si el mensaje es más largo que la llave, es necesario dividirlo en <strong>bloques</strong> del tamaño adecuado y usar un <strong>modo de operación</strong> que permita encadenar estos bloques.</p><p>El principio básico del proceso de Cifrado $E$ del cifrador de bloque consiste en ejecutar varias rondas de permutación y sustitución definidas sobre el bloque de texto plano $P$, de tal forma de obtener un nuevo bloque cifrado $C$. Las permutaciones y sustituciones son definidas por una llave $K$, la cual es entregada al cifrador de bloque como entrada, además de $C$. Para descifrar un bloque $C$ (proceso de descifrado $D$), se ejecutan operaciones inversas a las de $E$. Lo anterior se puede observar en la imagen siguiente, obtenida del libro <strong>Serious Cryptography</strong>.</p><p><img src=../cifrado.jpg alt="Esquema abstracto de los procesos de cifrado y descifrado"></p><p>Una característica importante para un buen cifrador, es que la salida $C$ no permita derivar nada ni de $K$ ni de $P$. Para esto, las salidas $C$ deben verse como datos aleatorios (es decir, no tener patrones).</p><p>El tamaño de la llave es importante para evitar ataques de fuerza bruta sobre el cifrador. Si la llave es pequeña no es una tarea imposible probar descifrar un bloque cifrado con todas las llaves posibles. Una llave de 16 bits requeriría del orden de 65 mil intentos para recorrer el espacio completo de llaves, mientras que una de 32 bits necesitaría 4 mil millones de intentos. Hoy en día es considerada segura una llave de largo 128 o más.</p><h3 id=tipos-de-cifradores-de-bloque>Tipos de cifradores de bloque<a href=#tipos-de-cifradores-de-bloque class=anchor aria-hidden=true>#</a></h3><p>Existen muchos diseños de cifradores de bloque. A continuación mencionaremos algunos de los más conocidos y usados.</p><h4 id=des>DES<a href=#des class=anchor aria-hidden=true>#</a></h4><p><img src=../des.png alt="Diagrama de especificación de DES"></p><p><strong>Estandarizado</strong> en el año 1977</p><p><strong>Largo de llave:</strong> 56 bits (+ 8 de paridad)</p><p><strong>Largo de bloque:</strong> 64 bits</p><p><strong>Rondas:</strong> 16</p><p><strong>Data Encryption Standard</strong> es un algoritmo de cifrado simétrico creado por IBM en los 70s. Se publicó como estándar el año 1977, con el tamaño de llave que conocemos. Este tamaño de llave hace que sea completamente factible un ataque de fuerza bruta en unos días, contando con la capacidad computacional adecuada o pagando por un servicio especializado.</p><p>Pueden encontrar una descripción bastante extensiva del algoritmo <a href=https://en.wikipedia.org/wiki/Data_Encryption_Standard>en Wikipedia</a>.</p><p>Existe una versión &ldquo;fortificada&rdquo; denominada <strong>3DES</strong> en la cual se aplica 3 veces el algoritmo DES a cada bloque, utilizando hasta 3 llaves ($K_1, K_2, K_3$) de 56 bits distintas, de la siguiente forma:</p><p>$$C = E_{K_3}(D_{K_2}(E_{K_1}(P)))$$
$$P = D_{K_1}(E_{K_2}(D_{K_3}(C)))$$</p><p>Sin embargo, esta versión es considerada insegura por el NIST desde el año 2017 debido a la existencia de ataques de colisión, como SWEET32. Más información sobre esta versión pueden encontrarla en <a href=https://en.wikipedia.org/wiki/Triple_DES>la página de Wikipedia</a></p><h4 id=aes>AES<a href=#aes class=anchor aria-hidden=true>#</a></h4><p><img src=../aes_rounds.jpg alt="Rondas AES"></p><p><strong>Estandarizado</strong> en el año 2000</p><p><strong>Largo de llave:</strong> 128, 192 o 256 bits</p><p><strong>Largo de bloque:</strong> 128 bits</p><p><strong>Rondas:</strong> 10, 12 o 14</p><p><strong>Advanced Encryption Standard</strong> es el cifrador de bloque por defecto hoy en día. Dependiendo del tamaño de la llave, consiste en entre 10 y 14 rondas de operaciones de substitución y permutación, tal como se muestra en la figura anterior (obtenida del libro <strong>Serious Cryptography</strong>)</p><p>Para mayor información sobre la utilidad de cada ronda, se les recomienda revisar el libro <strong>Serious Cryptography</strong> o la <a href=https://es.wikipedia.org/wiki/AES>página de Wikipedia</a></p><h3 id=modos-de-cifrado>Modos de Cifrado<a href=#modos-de-cifrado class=anchor aria-hidden=true>#</a></h3><p>Debido a que los cifradores de bloque pueden encargarse de cifrar datos de tamaño igual al tamaño del bloque, es necesario definir estrategias que permitan cifrar información de un largo mucho mayor. Acá entran en juego los &ldquo;modos de cifrado&rdquo;, los cuales definen el algoritmo a usar para realizar el cifrado de la información completa.</p><p>En todos los modos que se verán a continuación, se divide el texto completo en bloques de tamaño $BlockSize$. En caso que el texto completo no tenga un tamaño múltiplo de $BlockSize$, se agregan bytes al final de forma de rellenar (<em>padding</em>) y obtener un texto plano de un tamaño adecuado. Lo anterior genera un problema cuando el texto ya tiene un tamaño múltiplo de $BlockSize$, por lo que en esos casos es necesario agregar un bloque completo, solo con padding.</p><p>Algunos tipos de <em>padding</em>:</p><ul><li><strong>ANSI X9.23</strong>: Se rellena con bytes <code>\x00</code> o algún byte al azar, salvo el último byte del bloque rellenado, que incluye como valor la cantidad de bytes usados para rellenar.</li><li><strong>PKCS7</strong>: Se rellena con n bytes con el valor $hex(n)$, con $n \in [1,BlockSize]$.</li></ul><h4 id=ecb>ECB<a href=#ecb class=anchor aria-hidden=true>#</a></h4><p><img src=../ecb_enc.png alt="Cifrado ECB">
<img src=../ecb_dec.png alt="Descifrado ECB"></p><p><strong>Electronic Codebook</strong> es el modo de cifrado más simple. Cada bloque se cifra por separado usando siempre la misma llave, concatenándose todo para generar el texto cifrado.</p><h5 id=filtración-de-información-estructural>Filtración de información estructural<a href=#filtración-de-información-estructural class=anchor aria-hidden=true>#</a></h5><p>Si bien este modo es muy fácil de implementar, el mayor problema que posee es que es fácil encontrar patrones en los mensajes si los datos cifrados tienen una estructura que se repite bastante. Un muy buen ejemplo de lo anterior es esta imagen del <a href=https://isc.tamu.edu/~lewing/linux/>Pingüino Tux</a>, la cual si cifrásemos bloques de ella usando AES/ECB, podríamos ver ciertos patrones con bloques de colores parecidos que delinearían los bordes del pingüino.</p><p><img src=../tux.jpg alt=Tux>
<img src=../tux_ecb.jpg alt="Tux ECB"></p><h4 id=cbc>CBC<a href=#cbc class=anchor aria-hidden=true>#</a></h4><p><img src=../cbc_enc.png alt="Cifrado CBC">
<img src=../cbc_dec.png alt="Descifrado CBC"></p><p><strong>Cipher Block Chaining</strong> es un modo en el que el cifrado de cada bloque depende del resultado del cifrado del bloque anterior. Como caso especial, el primer bloque utiliza un valor público llamado <em>Vector de Inicialización</em> <code>(IV)</code>. Es importante que este valor sea aleatorio en cada sesión de cifrado, con el objetivo de impedir algunos tipos de ataques.</p><p>El cambio anterior con respecto a ECB ayuda a que si ciframos exactamente la misma información en dos bloques distintos, el resultado cifrado no sea el mismo, evitando problemas como los vistos con la imagen del pingüino.</p><h5 id=padding-oracle-attack>Padding Oracle Attack<a href=#padding-oracle-attack class=anchor aria-hidden=true>#</a></h5><p>Si contamos con feedback acerca del estado de un mensaje cifrado (específicamente, si el mensaje está bien formado o no), es posible ejecutar un ataque denominado <a href=https://en.wikipedia.org/wiki/Padding_oracle_attack>Padding Oracle Attack</a>. En el curso <a href=https://users.dcc.uchile.cl/~eriveros/cc5312/anexos/padding-oracle/>CC5312 Seguridad Computacional</a> se explica cómo ejecutar este ataque.</p><h5 id=maleabilidad-del-mensaje-cifrado-bit-flipping-attack>Maleabilidad del mensaje cifrado (Bit Flipping Attack)<a href=#maleabilidad-del-mensaje-cifrado-bit-flipping-attack class=anchor aria-hidden=true>#</a></h5><p>Revisemos de nuevo la imagen de Descifrado CBC y agreguemos al diagrama el estado justo antes de hacer XOR con el bloque anterior. A este estado le llamaremos $M$:</p><p><img src=../cbc_malleability.svg alt="Descifrado CBC"></p><p>Enfoquémonos primero en los bytes verdes. $IV_0$ es el primer byte del vector de inicialización. Si modificamos $IV_0$, podemos notar que el valor del primer caracter del texto plano ($P_{0,0}$) cambiará, debido a que ese caracter se obtiene combinando con $\oplus$ (xor) $M_{0,0}$ e $IV_0$.</p><p><strong>¿Pero por qué esto me genera un cambio solo en el primer byte si se supone que el block cipher revuelve los datos?</strong></p><p>Es verdad, un cifrador de bloque revuelve los datos de entrada. Esto quiere decir que si cambio un caracter en mi bloque de texto plano manteniendo la llave constante, el dato cifrado sera muy distinto al que tenía antes. Lo mismo en el caso de descifrar: si cambio un byte del dato cifrado, el texto descifrado será irreconocible comparado con el original.</p><p>Sin embargo, el valor descifrado por el block cipher en el modo CBC es un valor intermedio ($M$). Tanto este valor intermedio como el vector de inicialización <strong>sí tienen una dependencia lineal</strong> con respecto al valor descifrado.</p><p>Si conozco el texto original y quiero cambiar el primer caracter por un caracter $x$, puedo cambiar $IV_0$ por el siguiente valor:</p><p>$$\tilde{IV_0} = IV_0 \oplus P_{0,0} \oplus x$$</p><p>Lo anterior se cumple ya que sabemos que</p><p>$$P_{0,0} = M_{0,0} \oplus IV_0$$</p><p>Por lo que al reemplazar $IV_0$ por $\tilde{IV_0}$ tenemos que:</p><p>$$\tilde{P_{0,0}} = M_{0,0} \oplus IV_0 \oplus P_{0,0} \oplus x$$</p><p>reemplazando $M_{0,0} \oplus IV_0$, queda:</p><p>$$\tilde{P_{0,0}} = P_{0,0} \oplus P_{0,0} \oplus x$$</p><p>y como $a \oplus a = 0$:</p><p>$$\tilde{P_{0,0}} = x$$</p><p><strong>¿Puedo hacer esto con el segundo, tercer, enésimo byte?</strong></p><p>Si es en el primer bloque, ¡sí!. más abajo veremos el caso del segundo bloque.</p><p><strong>¿Y qué pasa si no tengo control sobre el IV?</strong></p><p>Si conoces el texto por debajo y tienes control sobre los bloques, puedes sacrificar un bloque específico para editar el contenido del bloque que viene justo después de él. Para esto, debemos ver los bloques rojos en la imagen anterior.</p><p><strong>¿Cómo modifico el segundo bloque? ¿y el tercero?</strong></p><p>En el caso puntual del texto del segundo bloque, la idea es hacer lo mismo que con el IV, pero usar el bloque cifrado $C_0,0$ (el primero) en vez de IV. Esto hará que el texto de ese bloque se rompa, pero nos permitirá cambiar el texto del bloque siguiente.</p><p>Lo anterior puedes aplicarlo no solo para modificar el segundo bloque cifrado. Basta con modificar el bloque cifrado anterior al que quieres editar.</p><p>(Esta explicación está basada en <a href=https://crypto.stackexchange.com/questions/66085/bit-flipping-attack-on-cbc-mode>esta respuesta</a> de Stack Overflow)</p><h4 id=ctr>CTR<a href=#ctr class=anchor aria-hidden=true>#</a></h4><p><img src=../ctr_enc.png alt="Cifrado CTR">
<img src=../ctr_dec.png alt="Descifrado CTR"></p><p><strong>Counter Mode</strong> es un modo que permite paralelizar el cifrado y descifrado de un mensaje, dado que la parte que pasa por el cifrador de bloque es un valor predeterminado y predecible. Además, el descifrado se ejecuta con el algoritmo de cifrado del cifrador de bloque elegido.</p><h2 id=cifradores-de-flujo>Cifradores de Flujo<a href=#cifradores-de-flujo class=anchor aria-hidden=true>#</a></h2><p>Los cifradores de flujo intentan emular el uso de un cifrador de tipo <strong>One-Time Pad</strong>, pero usando un generador de números <strong>pseudoaleatorio</strong>. Estos generadores usan una semilla realmente aleatoria al inicializarse, la cual les permite generar una salida continua extensa que se comporta de forma similar a un flujo de datos realmente aleatoria. Posteriormente, es posible cifrar un stream de datos simplemente haciendo $XOR$ entre los datos y el flujo pseudoaleatorio. Con tal de que ambas partes conozcan la semilla, es posible asegurar la sincronización entre sus flujos aleatorios, con lo que se es posible comunicarse sin problemas y sin filtrar los mensajes.</p><h3 id=el-_nonce_-en-los-cifradores-de-flujo>El <em>nonce</em> en los cifradores de flujo<a href=#el-_nonce_-en-los-cifradores-de-flujo class=anchor aria-hidden=true>#</a></h3><p>Partamos mencionando una potencial vulnerabilidad de los cifradores de flujo. Si se usa dos veces el mismo flujo pseudoaleatorio para dos conjuntos de datos (a partir del uso de la misma semilla), y luego se ejecuta la operación $XOR$ entre ambos textos cifrados, se obtendrá como resultado lo siguiente:</p><p>$$E(P_1) = P_1 \oplus S$$
$$E(P_2) = P_2 \oplus S$$
$$E(P_1) \oplus E(P_2) = (P_1 \oplus S) \oplus (P_2 \oplus S)$$
$$E(P_1) \oplus E(P_2) = (P_1 \oplus P_2)$$</p><p>Asumiendo que el texto plano tiene cierta estructura, luego no es difícil deducir qué valores corresponden a $P_1$ y $P_2$ a partir de $E(P_1) \oplus E(P_2)$.</p><p>Para evitar el problema anterior, los cifradores de flujo suelen recibir un parámetro extra, denominado <em>nonce</em>. Este campo puede ser considerado como público sin que esto signifique disminuir la seguridad del cifrador, pero <strong>debe ser distinto</strong> en cada ejecución del algoritmo, por lo que en algunas implementaciones corresponde simplemente a un contador que se incrementa en cada uso del cifrador. En caso que el nonce no siga una generación predecible, es necesario compartirlo entre ambas partes que desean comunicarse.</p><h3 id=rc4>RC4<a href=#rc4 class=anchor aria-hidden=true>#</a></h3><p><img src=../rc4.png alt="Generación Aleatoriedad RC4"></p><p><strong>Tamaño de llave</strong>: Entre 40 y 2048 bits.</p><p><strong>Tamaño del Nonce</strong>: No lleva de forma oficial, aunque se suele agregar como parte de la llave.</p><p>También conocido como <strong>ARCFOUR</strong>, es un cifrador de flujo diseñado el año 1987 pero filtrado el año 1994. Se comenzó a utilizar como un producto propietario de RSA Security, hasta que en el año 1994 se filtró su especificación en un foro cypherpunk.</p><p>Al hacerse público su funcionamiento, se empezaron a encontrar varios errores y vulnerabilidades en el algoritmo. Un ejemplo de estos problemas es que los primeros bytes de salida del generador pseudoaleatorio permiten adivinar el estado interno del mismo, derivándose así información sobre la clave.</p><p>Si bien su diseño no considera el uso de un nonce, éste se suele agregar de alguna de las formas siguientes:</p><ul><li>Hasheando la semilla y el nonce y usando el valor hasheado como semilla. Esta es la forma recomendada.</li><li>Concatenando la semilla con el nonce. Sin embargo, esto puede traer problemas de aleatoriedad debido a fallas propias de RC4.</li></ul><p>Es posible encontrar más información sobre este cifrador (y sus problemas) <a href=https://en.wikipedia.org/wiki/RC4>en wikipedia</a>.</p><h3 id=chacha>ChaCha<a href=#chacha class=anchor aria-hidden=true>#</a></h3><p><img src=../chacha.png alt="Ronda Chacha"></p><p><strong>Tamaño de llave</strong> 256 bits</p><p><strong>Tamaño del Nonce</strong> 64 bits</p><p>ChaCha es una familia de cifradores de flujo basada en una variante de Salsa20. Estos cifradores definen un estado inicial compuesto por &ldquo;palabras&rdquo; de 32 bit dispuestas en una matriz de 4x4:</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>(00) <code>expa</code></td><td>(01) <code>nd 3</code></td><td>(02) <code>2-by</code></td><td>(03) <code>te k</code></td></tr><tr><td>(04) <code>K</code></td><td>(05) <code>K</code></td><td>(06) <code>K</code></td><td>(07) <code>K</code></td></tr><tr><td>(08) <code>K</code></td><td>(09) <code>K</code></td><td>(10) <code>K</code></td><td>(11) <code>K</code></td></tr><tr><td>(12) <code>P</code></td><td>(13) <code>P</code></td><td>(14) <code>N</code></td><td>(15) <code>N</code></td></tr></tbody></table><p>Donde:</p><ul><li>(XX) representa el número del byte (se usa más abajo)</li><li><code>expand 32-byte k</code> es un texto en ASCII de 16 caracteres (4 <code>words</code> de 32 bits)</li><li><code>K</code> es la llave dividida en 8 bloques de 32 bits cada uno</li><li><code>P</code> (posición) es un contador que lleva cuenta de la cantidad de bloques cifrados.</li><li><code>N</code> corresponde a un <em>nonce</em>, es decir, un valor que no debe repetirse entre usos del sistema.</li></ul><p>Si bien el cifrado es de tipo &ldquo;flujo&rdquo;, los bytes de éste se generan de a bloques de tamaño 512 bits (16 bytes). Para generar el bloque de número $i$, se ejecutan los siguientes pasos:</p><ul><li>Se setean los bytes $P$ del estado <code>arr</code> en el valor binario de $i$</li><li>Se ejecuta 10 veces la siguiente operación en pseudocódigo (denominada &ldquo;doble ronda&rdquo;) sobre el estado:</li></ul><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>func</span> <span class=n>double_round</span><span class=p>():</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>12</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>14</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>15</span><span class=p>)</span>

  <span class=n>QR</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>15</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>12</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span>
  <span class=n>QR</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>9</span><span class=p>,</span> <span class=mi>14</span><span class=p>)</span>
</code></pre></div><p>Acá <code>QR</code> o <em>&ldquo;Quarter Round&rdquo;</em> se define de la siguiente forma:</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>QR</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>d</span><span class=p>):</span>
    <span class=n>arr</span><span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>b</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span><span class=o>^=</span><span class=n>arr</span><span class=p>[</span><span class=n>a</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>&lt;&lt;&lt;=</span> <span class=mi>16</span><span class=p>;</span>
    <span class=n>arr</span><span class=p>[</span><span class=n>c</span><span class=p>]</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>b</span><span class=p>]</span><span class=o>^=</span><span class=n>arr</span><span class=p>[</span><span class=n>c</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>b</span><span class=p>]</span> <span class=o>&lt;&lt;&lt;=</span> <span class=mi>12</span><span class=p>;</span>
    <span class=n>arr</span><span class=p>[</span><span class=n>a</span><span class=p>]</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>b</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span><span class=o>^=</span><span class=n>arr</span><span class=p>[</span><span class=n>a</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>&lt;&lt;&lt;=</span> <span class=mi>8</span><span class=p>;</span>
    <span class=n>arr</span><span class=p>[</span><span class=n>c</span><span class=p>]</span> <span class=o>+=</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span><span class=o>^=</span><span class=n>arr</span><span class=p>[</span><span class=n>c</span><span class=p>];</span> <span class=n>arr</span><span class=p>[</span><span class=n>d</span><span class=p>]</span> <span class=o>&lt;&lt;&lt;=</span> <span class=mi>7</span><span class=p>;</span> 
</code></pre></div><p>Y <code>x &lt;&lt;&lt;= y</code> corresponde a una &ldquo;rotación de y bits al valor x&rdquo;.</p><p>Finalmente, los valores correspondientes al estado luego de correr 10 veces la <em>double round</em> son XOReados con los datos, devolviendo el valor cifrado.</p><p>El descifrado se ejecuta de la misma forma, dado que XOR es una operación que se cancela a sí misma al ejecutarse dos veces sobre el mismo texto.</p><h2 id=más-allá-del-cifrado>Más allá del cifrado<a href=#más-allá-del-cifrado class=anchor aria-hidden=true>#</a></h2><p>Muchas veces, el cifrado no es suficiente para asegurar que una comunicación entre dos partes ocurre de forma segura. Un ejemplo: Si un mensaje cifrado no contiene metainformación acerca de cuándo fue mandado, un atacante podría reenviar mensajes de una persona a la otra, haciéndola pensar que se dijo nuevamente algo que en verdad no se dijo. Este ataque se denomina <code>Ataque de Repetición</code> (o Replay Attack), y se puede evitar agregando información secuencial al mensaje (por ejemplo, un contador monótono para cada participante).</p><p>Otro problema que puede ocurrir frente a una comunicación cifrada es que el mensaje sea alterado por un atacante antes de llegar al receptor. En el caso del cifrado de flujo, donde la modificación de un byte del texto cifrado altera solamente un byte del texto plano, una modificación de este estilo podría cambiar el significado del mensaje cifrado en una letra o símbolo. Para evitar este problema, es posible &ldquo;autentificar&rdquo; el mensaje a través de &ldquo;message authentication codes&rdquo; (MACs), los cuales permiten demostrar que el mensaje descifrado no ha sido intervenido de ninguna forma.</p><h3 id=mac>MAC<a href=#mac class=anchor aria-hidden=true>#</a></h3><p><strong>Message Authentication Code</strong></p><p>MAC es el nombre formal de este código extra que se agrega al mensaje cifrado para comprobar su autenticidad. Existen muchas formas de generar un MAC, a continuación nombramos algunas:</p><ul><li><strong>HMAC</strong> se genera a partir de una función de Hash.</li><li><strong>GCM</strong> se genera a partir del uso de un cifrador de bloque (Gallois-Counter mode).</li><li><strong>Poly1305</strong> utiliza polinomios y una función extra (AES, un generador como ChaCha20) para generar aleatoriedad a partir de una semilla.</li></ul><h4 id=enfoques-de-autentificación>Enfoques de autentificación<a href=#enfoques-de-autentificación class=anchor aria-hidden=true>#</a></h4><p>La autentificación del mensaje se podría realizar en tres puntos distintos. A continuación se muestran diagramas sobre cada forma de autentificar:</p><h5 id=encrypt-then-mac-etm><strong>Encrypt-Then-MAC (EtM)</strong><a href=#encrypt-then-mac-etm class=anchor aria-hidden=true>#</a></h5><p><img src=../etm.png alt="Encrypt Then MAC"></p><p>Corresponde a autentificar el mensaje ya cifrado. Es necesario usar una llave distintas para evitar ataques como <a href=https://en.wikipedia.org/wiki/CBC-MAC#Using_the_same_key_for_encryption_and_authentication>el que se menciona acá</a></p><h5 id=encrypt-and-mac-em><strong>Encrypt-And-MAC (E&M)</strong><a href=#encrypt-and-mac-em class=anchor aria-hidden=true>#</a></h5><p><img src=../eam.png alt="Encrypt And MAC"></p><p>En este caso no hay problemas con usar la misma llave para ambos procesos.</p><h5 id=mac-then-encrypt-mte><strong>MAC-Then-Encrypt (MtE)</strong><a href=#mac-then-encrypt-mte class=anchor aria-hidden=true>#</a></h5><p><img src=../mte.png alt="MAC then encrypt"></p><p>En este caso tampoco hay problemas con usar la misma llave para ambos procesos.</p><p>Más información sobre cada enfoque se puede encontrar en <a href=https://en.wikipedia.org/wiki/Authenticated_encryption#cite_note-14>Wikipedia</a>.</p><h3 id=cifrar-y-autentificar-a-la-vez>Cifrar y autentificar a la vez<a href=#cifrar-y-autentificar-a-la-vez class=anchor aria-hidden=true>#</a></h3><p>Existen ciertos algoritmos para cifrar datos que integran una rutina de autentificación en el proceso de cifrado. Mencionaremos brevemente dos de los más utilizados:</p><h3 id=aes-gcm-bloque>AES-GCM (Bloque)<a href=#aes-gcm-bloque class=anchor aria-hidden=true>#</a></h3><p><strong>Galois-Counter Mode</strong> es un modo de cifrado de bloque que además autentifica el mensaje cifrado. Este modo permite autentificar datos anexos a $P$ que necesiten ser autentificados, pero no cifrados. A esta información adicional no cifrada se le suele denominar $A$.</p><p><img src=../gcm.png alt="Galois-Counter Mode"></p><p>Más información sobre el algoritmo de autentificación <a href=https://en.wikipedia.org/wiki/Galois/Counter_Mode>en Wikipedia</a></p><h3 id=chacha20-poly1305-flujo>ChaCha20-Poly1305 (Flujo)<a href=#chacha20-poly1305-flujo class=anchor aria-hidden=true>#</a></h3><p><strong>ChaCha20-Poly1305</strong> corresponde al uso combinado del cifrador de flujo ChaCha20 y del MAC Poly1305. Su funcionamiento es explicado en el <a href=https://tools.ietf.org/html/rfc8439>RFC 8439</a>. Google seleccionó este algoritmo como reemplazo de RC4 en TLS/SSL. Este algoritmo suele preferirse sobre AES-GCM en hardware que no tiene procesadores optimizados para AES.</p><p class=edit-page><a href=https://github.com/cc5325/apunte/blob/main/content/docs/cripto-moderna/cripto-simetrica.md><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit-2"><path d="M17 3a2.828 2.828.0 114 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>Editar en GitHub</a>
<span class=date-info><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>Modificado por última vez el 01/04/2025 a las 21:28:03 hrs.</span></p><div class="docs-navigation d-flex justify-content-between"><a href=/docs/cripto-moderna/hashing/><div class="card my-1"><div class="card-body py-2">&larr; Hashing</div></div></a><a class=ml-auto href=/docs/cripto-moderna/cripto-asimetrica/><div class="card my-1"><div class="card-body py-2">Criptografía Asimétrica &rarr;</div></div></a></div></main></div></div></div><footer class="footer text-muted"><div class=container><div class=row><div class="col-lg-8 order-last order-lg-first"><ul class=list-inline><li class=list-inline-item>Sitio generado con <a href=https://gohugo.io/>Hugo</a> y <a href=https://getdoks.org/>Doks</a></li></ul></div><div class="col-lg-8 order-first order-lg-last text-lg-right"><ul class=list-inline><a href="http://creativecommons.org/licenses/by-sa/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-SA 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1"></a></ul></div></div></div></footer><script src=/main.2507c05f91ee016250e43b67b3d342f5a0d9d4dc5264f76cdc4518cd36a9e04cf3022ce8362802e618d8130b6733b53ee845a49e67229eeb3d3e70347db96a2b.js integrity="sha512-JQfAX5HuAWJQ5Dtns9NC9aDZ1NxSZPds3EUYzTap4EzzAizoNigC5hjYEwtnM7U+6EWknmcinus9PnA0fblqKw==" crossorigin=anonymous defer></script><script src=/index.min.32baa58f3bf5707baeb5ee3ffa608813f0eb538c3fb462f3710d762563fd1f2f1f54d4e4f44bbb49f92e2de87f3202d5b61ff622dcd0eb8b035a172fbd1b51d5.js integrity="sha512-Mrqljzv1cHuute4/+mCIE/DrU4w/tGLzcQ12JWP9Hy8fVNTk9Eu7SfkuLeh/MgLVth/2ItzQ64sDWhcvvRtR1Q==" crossorigin=anonymous defer></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true},options:{skipHtmlTags:['script','noscript','style','textarea','pre']}};window.addEventListener('load',(event)=>{document.querySelectorAll("mjx-container").forEach(function(x){x.parentElement.classList+='has-jax'})});</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>